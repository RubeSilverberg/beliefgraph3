# Belief Graph Tool - AI JSON Format Guide

**For AI Systems**: This guide explains how to create JSON files for belief graph networks. The system supports **minimal format** - you provide only essential data, and the converter handles the rest.

## Two Format Options

### Option 1: Minimal Format (Recommended for AI)
Simple structure with automatic expansion:
```json
{
  "nodes": [
    { "id": "evidence", "label": "Witness testimony" },
    { "id": "conclusion", "label": "Defendant is guilty" }
  ],
  "edges": [
    { "source": "evidence", "target": "conclusion", "type": "supports" }
  ]
}
```

### Option 2: Full Cytoscape Format
Complete structure with all visual properties:
```json
{
  "graph": [
    {
      "data": { "id": "evidence", "label": "Witness testimony" },
      "position": { "x": 100, "y": 200 },
      "group": "nodes"
    },
    {
      "data": { "id": "edge1", "source": "evidence", "target": "conclusion" },
      "group": "edges"
    }
  ]
}
```

**Workflow**: Create minimal format → Load in test converter → Save as full format → Use in main tool

## Minimal Format Specification

### Required Fields

**Nodes (minimum):**
```json
{ "id": "unique_id" }
```

**Nodes (typical):**
```json
{ 
  "id": "unique_id",
  "label": "Short label",
  "type": "fact"
}
```
(`"type"` needed only for `"fact"`, `"and"`, `"or"`, or `"note"`. Omit for normal assertions.)

### Dual Node Text Fields

Each node can carry two complementary textual forms:

- `label`: 1–3 words (or a very short phrase) used for on-node display.
- `description`: A full, self-contained sentence (ends with a period) used as hover text. It should restate or clarify the short label.

Guidelines:
- Keep `label` concise; avoid trailing punctuation.
- Use `description` to add scope, qualifiers, or definitions.
- Notes (`type: "note"`) typically use multi-line `description`.

Example:
```json
{ "id": "dna1", "label": "DNA Match", "description": "Forensic testing found a high-confidence DNA match to the suspect." }
```

**Edges (minimum):**
```json
{ "source": "node_id", "target": "node_id" }
```

**Edges (with influence):**
```json
{ 
  "source": "node_id", 
  "target": "node_id", 
  "type": "supports",
  "weight": 0.85
}
```

### Defaults (if omitted)
- Node `"type"`: Assigned by converter as `"fact"` (no incoming edges) or `"assertion"` (otherwise)
- Edge `"type"`: Defaults to `"supports"`
- Edge `"weight"`: If omitted for assertion targets, defaults to `0.15`

### Auto-Generated by Converter
- Unique edge IDs
- Node positions (automatic layout)
- Node types (fact/assertion based on connections)
- Visual styling (colors, sizes, fonts)
- Cytoscape properties (group, position, etc.)
- Any properties not specified in minimal format are auto-generated

### Node Types (Auto-Detection + Manual Override)

1. **Facts**: Nodes with no incoming edges (auto-detected)
2. **Assertions**: Nodes with incoming edges (auto-detected)  
3. **Logic nodes**: Must specify `"type": "and"` or `"type": "or"`
4. **Notes**: Must specify `"type": "note"`

**Rules**:
- If `"type"` is omitted, converter assigns `"fact"` (no incoming edges) or `"assertion"` (has incoming edges)
- `"type"` **must** be specified for `"and"`, `"or"`, or `"note"` nodes
- For edges, `"type"` defaults to `"supports"` if omitted

### Edge Influence System

**Weights** (Lite mode - current converter support):
- `0.15` = Minimal influence
- `0.35` = Small influence  
- `0.60` = Medium influence
- `0.85` = Strong influence
- `1.0` = Maximal influence

**Required**: Edge `weight` must be specified for edges targeting assertion nodes. If omitted, converter assigns default minimal influence (0.15).
**Polarity**: Prefer `type: "opposes"` over negative weights for clarity (negative weights still accepted if allowed).

## Optional Customizations

**Node styling** (optional):
```json
{
  "id": "custom_node",
  "label": "Important Evidence", 
  "description": "Hover text shown on node",
  "textColor": "#ffffff",
  "sizeIndex": 5,
  "position": { "x": 100, "y": 200 }
}
```

**Edge annotations:**
```json
{
  "source": "A", "target": "B",
  "type": "supports", 
  "weight": 0.6,
  "contributingFactors": [
    "Independent lab test",
    "High sample quality",
    "Chain-of-custody intact"
  ],
  "rationale": "(Optional) Longer narrative explanation if bullets insufficient"
}
```

### Contributing Factors vs Rationale

- `contributingFactors`: Preferred. Ordered array of short (≈3–7 word) phrases shown directly on hover. No periods; each is one distinct aspect.
- `rationale`: Longer paragraph (legacy / deep dive). Provide only when necessary.

Example edge:
```json
{
  "source": "evidence1",
  "target": "claim1",
  "type": "supports",
  "weight": 0.60,
  "contributingFactors": [
    "Consistent eyewitness reports",
    "Timestamped video corroboration",
    "No alibi contradictions"
  ]
}
```

## Structure Rules

1. **No cycles**: Must be Directed Acyclic Graph (DAG)
2. **Unique IDs**: All node/edge IDs must be unique
3. **Valid connections**: Source/target must reference existing node IDs
4. **Notes are isolated**: Notes cannot connect to other nodes

## Practical Examples

### Simple Investigation
```json
{
  "nodes": [
    { "id": "witness", "label": "Witness testimony", "type": "fact" },
    { "id": "dna", "label": "DNA evidence", "type": "fact" },
    { "id": "guilt", "label": "Defendant is guilty" }
  ],
  "edges": [
    { "source": "witness", "target": "guilt", "type": "supports", "weight": 0.6 },
    { "source": "dna", "target": "guilt", "type": "supports", "weight": 0.85 }
  ]
}
```

### Logic Operations
```json
{
  "nodes": [
    { "id": "cond1", "label": "Condition A" },
    { "id": "cond2", "label": "Condition B" }, 
    { "id": "both", "label": "Both conditions", "type": "and" },
    { "id": "result", "label": "Final conclusion" }
  ],
  "edges": [
    { "source": "cond1", "target": "both" },
    { "source": "cond2", "target": "both" },
    { "source": "both", "target": "result", "weight": 0.85 }
  ]
}
```

## JSON Creation Workflow

1. **Generate minimal JSON** with nodes and edges
2. **Save as `.json`** file in `/tests/minimal-json/` folder
3. **Open converter**: `/tests/minimal-json/test-minimal-converter.html`
4. **Load your file** - system expands to full format
5. **Export to main tool** - save as complete graph file
6. **Use in main interface** - load the expanded file normally

## Loading Paths

- **Minimal files**: Use `/tests/minimal-json/test-minimal-converter.html`
- **Full files**: Use main interface `/index.html` Load button
- **Examples**: Use main interface Examples button

The converter handles all visual properties, positioning, and format requirements automatically.

### Minimal Format Schema & Module

- Core module: `format-core.js` (attaches `BeliefGraphFormatCore`)
- ES module wrapper: `format.js` (named exports)
- JSON Schema: `minimal-format.schema.json` (draft-07) for validation or AI prompting

Example (in browser console after cy initialized):
```js
const minimal = BeliefGraphFormat.exportMinimalGraph(window.cy);
console.log(minimal);
// To import (auto-detect any supported shape):
BeliefGraphFormat.importAnyGraph(window.cy, minimal);
// With validation (throws on structural/semantic errors):
BeliefGraphFormat.importAnyGraph(window.cy, minimal, { validate: true });
```

### Validation Helper (Lightweight)

File: `validation.js` adds a fast structural & semantic checker (no external libs).

API:
```js
const { valid, errors, warnings } = BeliefGraphFormatValidate.validateMinimal(minimal, {
  strict: false,        // if true, warn on missing inferred node types
  checkCycles: true,    // detect directed cycles
  allowNegativeWeights: true // if false, negative weights become errors
});
```

Import with validation (throws if invalid):
```js
BeliefGraphFormat.importAnyGraph(cy, data, { validate: true });
```

Checks performed:
- Required arrays (nodes, edges)
- Unique node IDs
- Edge endpoints reference existing nodes
- Allowed node / edge types
- Probability range 0..1
- CPT numeric ranges 0..100
- Weight range -1..1 (and negativity rule)
- Notes isolated (no edges touching notes)
- Duplicate source->target edge pairs (warning)
- Directed cycle detection (error)

Returns errors (blocking) and warnings (non-blocking) to aid AI self-audit.

## Developer Tools (optional)

- Developer utilities live under `tests/dev-tools/` (no root stubs anymore).
  - `autonomous-bug-hunter.js` – automated checks (inject via snippet in tools page)
  - `json-compatibility-checker.js` – schema analysis & migration hints
  - See `tests/dev-tools/index.html` for usage snippets.

Minimal JSON converter prototype artifacts are grouped in `tests/minimal-json/` (prototype logic in `minimal-format-analysis.js`, core in `format-core.js`):
- `test-ultra-minimal.json` – absolute-minimum example
- `test-minimal.json` – richer example with visuals/logic
- `test-minimal-converter.html` – interactive converter harness

### Legacy Stub Files

Remain only to avoid breaking stale references; inert and safe to delete later:

- `autonomous-bug-hunter.js` (stub) – real tool: `tests/dev-tools/autonomous-bug-hunter.js`
- `json-compatibility-checker.js` (stub) – real tool: `tests/dev-tools/json-compatibility-checker.js`

Purpose: assist automated agents and contributors in ignoring obsolete entry points.

## Do-calculus (Heavy Mode Only)

This project ships a minimal, modular do-calculus helper designed for Bayes Heavy mode. It simulates Pearl-style interventions by cutting incoming edges to intervened nodes and freezing their probabilities during a transactional run.

- Module: `do-calculus.js` (auto-loaded in `index.html`)
- Global helper: `window.doCalc`
- Heavy-only: If the current mode is not heavy, helpers become no-ops and just run your function.

API:

- `doCalc.computeDo({ A: 1, B: 0 })` → `{ probsById, getProb(id) }` snapshot of probabilities under the intervention
- `doCalc.ate(xId, yId)` → `{ p1, p0, ate }` for P(Y|do(X=1)) - P(Y|do(X=0))
- `doCalc.isDSeparated(X, Y, Z)` → boolean via moralized ancestral-graph test
- `doCalc.satisfiesBackdoor(X, Y, Z)` → boolean (sufficient check by removing outgoing from X then d-sep)
- `doCalc.withIntervention({ X: 1 }, () => { /* read cy, compute stats, etc. */ })` – runs your fn with the do() applied, then restores the graph.

Example in console (after switching to Heavy mode):

```js
// Toggle to heavy mode in the UI, then:
const { probsById, getProb } = doCalc.computeDo({ someNode: 1 });
console.log('P(Y|do(someNode=1)) =', getProb('Y'));
console.log('ATE(X→Y) =', doCalc.ate('X','Y'));
```
