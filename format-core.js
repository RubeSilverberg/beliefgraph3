// format-core.js - Core minimal format utilities (stable experimental)
// Provides concise export/import without visual/runtime noise.
(function(global){
  function detectFormat(json){ if(Array.isArray(json)) return 'elements'; if(json&&Array.isArray(json.graph)) return 'graph-wrapper'; if(json&&Array.isArray(json.nodes)&&Array.isArray(json.edges)) return 'minimal'; return 'unknown'; }
  function nodeType(d){ const allowed=['fact','assertion','and','or','note']; return (d.type&&allowed.includes(d.type))?d.type:'assertion'; }
  function styleOut(d){ const s={}; if(d.textColor) s.textColor=d.textColor; if(d.sizeIndex&&d.sizeIndex!==3) s.sizeIndex=d.sizeIndex; if(d.floretColor) s.floretColor=d.floretColor; return Object.keys(s).length?s:undefined; }
  function pruneCpt(cpt){ if(!cpt) return; const {condTrue,condFalse,baseline,inverse}=cpt; const o={}; if(typeof condTrue==='number') o.condTrue=condTrue; if(typeof condFalse==='number') o.condFalse=condFalse; if(typeof baseline==='number') o.baseline=baseline; if(inverse===true) o.inverse=true; return Object.keys(o).length?o:undefined; }
  function exportMinimalGraph(cy,{includePositions=true,version='2'}={}){ if(!cy) throw new Error('cy required'); const nodes=cy.nodes().map(n=>{const d=n.data(); const o={id:d.id,label:d.origLabel||d.label||d.id,type:nodeType(d)}; if(d.hoverLabel) o.description=d.hoverLabel; if(typeof d.prob==='number') o.prob=d.prob; if(d.cpt){const pc=pruneCpt(d.cpt); if(pc) o.cpt=pc;} const st=styleOut(d); if(st) o.style=st; return o;}); const edges=cy.edges().map(e=>{const d=e.data(); const w=d.userAssignedWeight??d.weight; const o={id:d.id,source:d.source,target:d.target,type:d.type||'supports'}; if(typeof w==='number') o.weight=w; if(d.rationale) o.rationale=d.rationale; if(d.cpt){const pc=pruneCpt(d.cpt); if(pc) o.cpt=pc;} return o;}); const out={version,nodes,edges}; const ann=global.textAnnotations?.exportAnnotations?.(); if(ann&&ann.length) out.annotations=ann; if(includePositions){const pos={}; cy.nodes().forEach(n=>{const p=n.position(); pos[n.id()]={x:p.x,y:p.y};}); out.layout={positions:pos};} return out; }
  function normalizeFromElements(elements){ const nodes=[]; const edges=[]; (elements||[]).forEach(el=>{ if(!el||!el.data) return; if(el.group==='nodes'||(!el.data.source&&!el.data.target)){const d=el.data; const o={id:d.id,label:d.origLabel||d.label||d.id,type:nodeType(d)}; if(d.hoverLabel) o.description=d.hoverLabel; if(typeof d.prob==='number') o.prob=d.prob; if(d.cpt){const pc=pruneCpt(d.cpt); if(pc) o.cpt=pc;} const st=styleOut(d); if(st) o.style=st; nodes.push(o);} else { const d=el.data; const w=d.userAssignedWeight??d.weight; const o={id:d.id,source:d.source,target:d.target,type:d.type||'supports'}; if(typeof w==='number') o.weight=w; if(d.rationale) o.rationale=d.rationale; if(d.cpt){const pc=pruneCpt(d.cpt); if(pc) o.cpt=pc;} edges.push(o);} }); return {version:'2',nodes,edges}; }
  function migrateGraphWrapper(json){ const m=normalizeFromElements(json.graph||[]); if(json.textAnnotations) m.annotations=json.textAnnotations; return m; }
  function migrateMinimalV1(json){ const c=JSON.parse(JSON.stringify(json)); c.version='2'; return c; }
  function normalizeAny(json){ const kind=detectFormat(json); switch(kind){ case 'elements': return normalizeFromElements(json); case 'graph-wrapper': return migrateGraphWrapper(json); case 'minimal': return json.version==='2'?json:migrateMinimalV1(json); default: throw new Error('Unrecognized format'); } }
  function expandToElements(minimal){ const els=[]; minimal.nodes.forEach(n=>{ const d={id:n.id,label:n.label,origLabel:n.label,type:nodeType(n)}; if(n.description) d.hoverLabel=n.description; if(typeof n.prob==='number') d.prob=n.prob; if(n.cpt) d.cpt={...n.cpt}; if(n.style){ if(n.style.textColor) d.textColor=n.style.textColor; if(n.style.sizeIndex) d.sizeIndex=n.style.sizeIndex; if(n.style.floretColor) d.floretColor=n.style.floretColor; } const position=minimal.layout?.positions?.[n.id]; els.push({group:'nodes',data:d,position}); }); minimal.edges.forEach(e=>{ const d={id:e.id,source:e.source,target:e.target,type:e.type||'supports'}; if(typeof e.weight==='number'){ d.weight=e.weight; d.userAssignedWeight=e.weight; } if(e.rationale) d.rationale=e.rationale; if(e.cpt) d.cpt={...e.cpt}; els.push({group:'edges',data:d}); }); return els; }
  global.BeliefGraphFormatCore={detectFormat,exportMinimalGraph,normalizeAny,expandToElements};
})(typeof window!=='undefined'?window:globalThis);

// End of format-core.js
