<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minimal JSON Test</title>
  <meta name="page-id" content="minimal-converter" />
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
    .output { background: #f5f5f5; padding: 10px; margin: 10px 0; font-family: monospace; white-space: pre-wrap; }
    button { padding: 10px 15px; margin: 5px; }
  </style>
</head>
<body>
  <script>
    (function(){
      const pidEl = document.querySelector('meta[name="page-id"]');
      const pid = pidEl ? pidEl.content : '(missing)';
      window.BELIEFGRAPH_PAGE_ID = pid;
      console.log('[BeliefGraph] Converter page loaded. Page ID:', pid, 'Path:', location.pathname);
      // If somehow main app assets leak in, we could detect known main-only element
      if(pid === 'minimal-converter' && document.getElementById('cy')){
        console.warn('[BeliefGraph] Unexpected main app canvas detected inside converter page.');
      }
    })();
  </script>
  <div style="background:#ffe9b3;padding:8px 12px;border:1px solid #d8b75c;font:14px/1.4 Arial, sans-serif;margin-bottom:12px;border-radius:4px;">
    <strong>Playground:</strong> This is a test / conversion sandbox (not the main app). Use it to load, validate, and convert minimal JSON before opening <code>../index.html</code>.
  </div>
  <h1>Minimal JSON Format Test</h1>
  <div class="test-section" style="border:2px solid #9c7e39;background:#fff9ea;">
    <h2>0. Paste Minimal JSON (Quick Converter)</h2>
    <textarea id="paste-input" style="width:100%;min-height:140px;font-family:monospace;font-size:13px;padding:8px;box-sizing:border-box;" placeholder='{"nodes":[{"id":"a"},{"id":"b"}],"edges":[{"source":"a","target":"b"}]}'></textarea>
    <div style="margin-top:8px;">
      <button onclick="pasteConvertDownload()">Convert & Download graph.json</button>
      <button onclick="pasteConvertOpen()">Open In Main App (new tab)</button>
      <button onclick="pasteClear()">Clear</button>
      <span id="paste-status" style="margin-left:10px;font-size:12px;color:#555;"></span>
    </div>
    <p style="font-size:12px;margin-top:6px;line-height:1.3;">Steps: Paste minimal JSON above. Click Convert & Download to get a file you can load in the main tool. Or click Open In Main App to auto-store it and open the app.</p>
  </div>
  
  <div class="test-section">
    <h2>1. Load Minimal JSON File</h2>
    <button onclick="loadMinimalJson()">Load test-minimal.json (Complex)</button>
    <button onclick="loadUltraMinimal()">Load test-ultra-minimal.json (Simple)</button>
    <button onclick="loadAdnanCase()">Load Adnan.json (Your Case)</button>
    <div id="minimal-output" class="output"></div>
  </div>
  
  <div class="test-section">
    <h2>2. Convert to Full Format</h2>
    <button onclick="convertToFull()">Convert to Full JSON</button>
    <button onclick="validateMinimalNow()">Validate Minimal JSON</button>
    <div id="full-output" class="output"></div>
  </div>
  
  <div class="test-section">
    <h2>3. Test Simple Minimal Format</h2>
    <button onclick="testSimpleMinimal()">Test Ultra-Minimal Format</button>
    <div id="simple-output" class="output"></div>
  </div>
  
  <div class="test-section">
    <h2>4. Test Built-in Examples</h2>
    <button onclick="testAllExamples()">Test All Example Formats</button>
    <div id="examples-output" class="output"></div>
  </div>
  
  <div class="test-section">
    <h2>5. Test with Belief Graph Tool</h2>
    <button onclick="testWithBeliefGraph()">Open in Belief Graph</button>
    <div id="test-output" class="output"></div>
  </div>

  <script src="../../format-core.js"></script>
  <script src="../../validation.js"></script>
  <script src="../../minimal-format-analysis.js"></script>
  <script>
    let minimalData = null;
    let fullData = null;
    function parseLooseMinimal(text){
      let src = text.trim();
      if(!src) throw new Error('Empty input');
      // Strip BOM
      src = src.replace(/^\uFEFF/, '');
      // Remove leading const/let/var name =
      src = src.replace(/^(?:const|let|var)\s+[a-zA-Z0-9_$]+\s*=\s*/, '');
      // Remove trailing exports like module.exports =
      src = src.replace(/^module\.exports\s*=\s*/, '');
      // Remove trailing semicolon
      src = src.replace(/;\s*$/, '');
      // Remove // comments
      src = src.replace(/(^|[^:])\/\/.*$/gm, '$1');
      // Remove /* */ comments
      src = src.replace(/\/\*[\s\S]*?\*\//g, '');
      const tryJson = src;
      try { return JSON.parse(tryJson); } catch(_e) {}
      // If looks like object literal without quotes on keys or single quotes, attempt JS eval
      try {
        // Wrap in parentheses so object literals parse
        // eslint-disable-next-line no-new-func
        const obj = Function('return ( '+ src + ' )');
        return obj();
      } catch(e){
        // Fallback: detect separate var version/nodes/edges declarations
        try {
          const versionMatch = text.match(/var\s+version\s*=\s*(["'`])(.*?)\1/)
                                 || text.match(/const\s+version\s*=\s*(["'`])(.*?)\1/)
                                 || text.match(/let\s+version\s*=\s*(["'`])(.*?)\1/);
        // Final fallback: try executing the whole snippet in an isolated function scope
        try {
          const wrapper = `return (function(){\n${text}\nreturn { version: (typeof version!=='undefined'?version:undefined), nodes: (typeof nodes!=='undefined'?nodes:[]), edges: (typeof edges!=='undefined'?edges:[]) };\n})();`;
          const result = Function(wrapper)();
          if(result && Array.isArray(result.nodes) && Array.isArray(result.edges)){
            result.edges.forEach(e=>{ if(e && typeof e==='object'){ if(e.from && !e.source) e.source=e.from; if(e.to && !e.target) e.target=e.to; delete e.from; delete e.to; } });
            return result;
          }
        } catch(execErr){ /* ignore; will throw generic error below */ }
          const nodesMatch = text.match(/\b(var|let|const)\s+nodes\s*=\s*(\[[\s\S]*?\]);?/);
          const edgesMatch = text.match(/\b(var|let|const)\s+edges\s*=\s*(\[[\s\S]*?\]);?/);
          if(nodesMatch){
            const nodesArr = Function('return ' + nodesMatch[2])();
            const edgesArr = edgesMatch ? Function('return ' + edgesMatch[2])() : [];
            const minimal = { version: versionMatch? versionMatch[2] : undefined, nodes: nodesArr, edges: edgesArr };
            // Normalize edge field names (from/to -> source/target)
            minimal.edges.forEach(e=>{
              if(e.from && !e.source) e.source = e.from;
              if(e.to && !e.target) e.target = e.to;
              delete e.from; delete e.to;
            });
            return minimal;
          }
        } catch(fbErr){ /* swallow and throw generic error below */ }
        throw new Error('Could not parse as JSON, JS object, or var nodes/edges snippet');
      }
    }
    function pasteClear(){
      document.getElementById('paste-input').value='';
      document.getElementById('paste-status').textContent='';
    }
    function pasteConvertDownload(){
      const status = document.getElementById('paste-status');
      try {
        const txt = document.getElementById('paste-input').value.trim();
        if(!txt){ status.textContent='(Nothing pasted)'; return; }
  let minimal;
  try { minimal = JSON.parse(txt); }
  catch(_e){ minimal = parseLooseMinimal(txt); }
        const full = window.createFullJsonFromMinimalInput(minimal);
        const blob = new Blob([JSON.stringify(full.graph, null, 2)], {type:'application/json'});
        const a=document.createElement('a');
        a.href=URL.createObjectURL(blob);
        a.download='graph.json';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
        status.textContent='Downloaded graph.json';
      } catch(e){
        console.error(e);
        status.textContent='Error: '+ e.message;
      }
    }
    function pasteConvertOpen(){
      const status = document.getElementById('paste-status');
      try {
        const txt = document.getElementById('paste-input').value.trim();
        if(!txt){ status.textContent='(Nothing pasted)'; return; }
  let minimal;
  try { minimal = JSON.parse(txt); }
  catch(_e){ minimal = parseLooseMinimal(txt); }
        const full = window.createFullJsonFromMinimalInput(minimal);
        // Store in localStorage using existing key expectation
        localStorage.setItem('testGraphData', JSON.stringify({ graph: full.graph, textAnnotations: [] }));
        status.textContent='Stored + opening main app...';
        window.open('../../index.html', '_blank');
      } catch(e){
        console.error(e);
        status.textContent='Error: '+ e.message;
      }
    }
    
    async function loadMinimalJson() {
      try {
        const response = await fetch('test-minimal.json');
        minimalData = await response.json();
        document.getElementById('minimal-output').textContent = 
          'Loaded minimal JSON:\n' + JSON.stringify(minimalData, null, 2);
      } catch (error) {
        document.getElementById('minimal-output').textContent = 
          'Error loading minimal JSON: ' + error.message;
      }
    }
    
    async function loadUltraMinimal() {
      try {
        const response = await fetch('test-ultra-minimal.json');
        minimalData = await response.json();
        document.getElementById('minimal-output').textContent = 
          'Loaded ultra-minimal JSON:\n' + JSON.stringify(minimalData, null, 2);
      } catch (error) {
        document.getElementById('minimal-output').textContent = 
          'Error loading ultra-minimal JSON: ' + error.message;
      }
    }
    
    async function loadAdnanCase() {
      try {
        const response = await fetch('Adnan.json');
        minimalData = await response.json();
        document.getElementById('minimal-output').textContent = 
          'Loaded Adnan case JSON:\n' + JSON.stringify(minimalData, null, 2);
      } catch (error) {
        document.getElementById('minimal-output').textContent = 
          'Error loading Adnan JSON: ' + error.message;
      }
    }
    
    function convertToFull() {
      if (!minimalData) {
        document.getElementById('full-output').textContent = 
          'Please load minimal JSON first';
        return;
      }
      
      try {
        fullData = window.createFullJsonFromMinimalInput(minimalData);
        document.getElementById('full-output').textContent = 
          'Converted to full JSON:\n' + JSON.stringify(fullData, null, 2);
      } catch (error) {
        document.getElementById('full-output').textContent = 
          'Error converting: ' + error.message;
      }
    }
    
    function testSimpleMinimal() {
      console.log("🧪 Testing simple minimal format with missing information");
      
      // Ultra-minimal format - just IDs and connections
      const ultraMinimal = {
        nodes: [
          { id: 'a' },
          { id: 'b' }, 
          { id: 'c' }
        ],
        edges: [
          { source: 'a', target: 'b' },
          { source: 'b', target: 'c', weight: 0.7 }
        ]
      };
      
      try {
        const result = window.createFullJsonFromMinimalInput(ultraMinimal);
        document.getElementById('simple-output').textContent = 
          '✅ Ultra-minimal conversion successful!\n\n' +
          'Input (ultra-minimal):\n' + JSON.stringify(ultraMinimal, null, 2) + 
          '\n\nOutput (full format):\n' + JSON.stringify(result, null, 2);
          
        console.log("✅ Ultra-minimal test passed!", result);
      } catch (error) {
        document.getElementById('simple-output').textContent = 
          '❌ Ultra-minimal conversion failed:\n' + error.message;
        console.error("❌ Ultra-minimal test failed:", error);
      }
    }
    
    function testAllExamples() {
      console.log("🧪 Testing all built-in examples");
      
      const results = [];
      
      if (window.MINIMAL_INPUT_EXAMPLES) {
        Object.entries(window.MINIMAL_INPUT_EXAMPLES).forEach(([name, example]) => {
          try {
            const result = window.createFullJsonFromMinimalInput(example);
            const nodeCount = result.graph.filter(el => el.group === 'nodes').length;
            const edgeCount = result.graph.filter(el => el.group === 'edges').length;
            
            results.push(`✅ ${name}: ${nodeCount} nodes, ${edgeCount} edges`);
            console.log(`✅ Example "${name}" converted successfully`);
          } catch (error) {
            results.push(`❌ ${name}: ${error.message}`);
            console.error(`❌ Example "${name}" failed:`, error);
          }
        });
      } else {
        results.push('❌ MINIMAL_INPUT_EXAMPLES not available');
      }
      
      document.getElementById('examples-output').textContent = 
        'Built-in Examples Test Results:\n\n' + results.join('\n');
    }
    
    function testWithBeliefGraph() {
      if (!fullData) {
        document.getElementById('test-output').textContent = 
          'Please convert to full JSON first';
        return;
      }
      
      // Save the full data to localStorage so the main tool can load it
  localStorage.setItem('testGraphData', JSON.stringify({ graph: fullData.graph, textAnnotations: [] }));
      document.getElementById('test-output').textContent = 
        'Full JSON saved to localStorage as "testGraphData"\n' +
        'You can now open the main tool and load this data';
      
      // Open the main tool
      window.open('../../index.html', '_blank');
    }

    function validateMinimalNow(){
      if(!minimalData){
        document.getElementById('full-output').textContent = 'Please load minimal JSON first';
        return;
      }
      if(!window.BeliefGraphFormatValidate){
        document.getElementById('full-output').textContent = 'Validation module not loaded';
        return;
      }
      const res = window.BeliefGraphFormatValidate.validateMinimal(minimalData, { checkCycles:true });
      document.getElementById('full-output').textContent = 'Validation Result:\n' + JSON.stringify(res, null, 2);
      console[res.valid? 'log':'warn']('[Validation]', res);
    }
  </script>
</body>
</html>
